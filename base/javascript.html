<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS部分 | 前端面试宝典</title>
    <meta name="description" content="大厂前端面试题整理">
    <link rel="icon" href="/front_end_studying/avatar.jpg">
    
    <link rel="preload" href="/front_end_studying/assets/css/0.styles.0373d4c1.css" as="style"><link rel="preload" href="/front_end_studying/assets/js/app.9eec5fda.js" as="script"><link rel="preload" href="/front_end_studying/assets/js/6.14b46a33.js" as="script"><link rel="prefetch" href="/front_end_studying/assets/js/10.4924765d.js"><link rel="prefetch" href="/front_end_studying/assets/js/11.993bcc99.js"><link rel="prefetch" href="/front_end_studying/assets/js/12.2aeaf266.js"><link rel="prefetch" href="/front_end_studying/assets/js/13.542f4e4d.js"><link rel="prefetch" href="/front_end_studying/assets/js/14.45795388.js"><link rel="prefetch" href="/front_end_studying/assets/js/15.96e5648e.js"><link rel="prefetch" href="/front_end_studying/assets/js/16.ff3a5cd8.js"><link rel="prefetch" href="/front_end_studying/assets/js/17.a0170075.js"><link rel="prefetch" href="/front_end_studying/assets/js/18.2a23d5f9.js"><link rel="prefetch" href="/front_end_studying/assets/js/19.0c4dabed.js"><link rel="prefetch" href="/front_end_studying/assets/js/2.d222fbca.js"><link rel="prefetch" href="/front_end_studying/assets/js/20.87104d4f.js"><link rel="prefetch" href="/front_end_studying/assets/js/21.f7903bda.js"><link rel="prefetch" href="/front_end_studying/assets/js/3.23267d51.js"><link rel="prefetch" href="/front_end_studying/assets/js/4.4eab954a.js"><link rel="prefetch" href="/front_end_studying/assets/js/5.1754e614.js"><link rel="prefetch" href="/front_end_studying/assets/js/7.09f12188.js"><link rel="prefetch" href="/front_end_studying/assets/js/8.03407f1f.js"><link rel="prefetch" href="/front_end_studying/assets/js/9.d435ade3.js">
    <link rel="stylesheet" href="/front_end_studying/assets/css/0.styles.0373d4c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front_end_studying/" class="home-link router-link-active"><!----> <span class="site-name">前端面试宝典</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front_end_studying/base/html.html" class="nav-link">HTML</a></div><div class="nav-item"><a href="/front_end_studying/base/css.html" class="nav-link">CSS</a></div><div class="nav-item"><a href="/front_end_studying/base/javascript.html" class="nav-link router-link-exact-active router-link-active">JavaScript</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">MVVM</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/vue.html" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react.html" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/angular.html" class="nav-link">Angular</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/weex.html" class="nav-link">Weex</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react-native.html" class="nav-link">React Native</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/flutter.html" class="nav-link">Flutter</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/miniprogram.html" class="nav-link">小程序</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/network.html" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/data_structure.html" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/algorithm.html" class="nav-link">算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">常用代码</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/code/easy.html" class="nav-link">LeetCode - 简单</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/medium.html" class="nav-link">LeetCode - 中等</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/difficulty.html" class="nav-link">LeetCode - 困难</a></li></ul></div></div><div class="nav-item"><a href="https://llwanran.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/LLwanran" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front_end_studying/base/html.html" class="nav-link">HTML</a></div><div class="nav-item"><a href="/front_end_studying/base/css.html" class="nav-link">CSS</a></div><div class="nav-item"><a href="/front_end_studying/base/javascript.html" class="nav-link router-link-exact-active router-link-active">JavaScript</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">MVVM</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/vue.html" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react.html" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/angular.html" class="nav-link">Angular</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/weex.html" class="nav-link">Weex</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react-native.html" class="nav-link">React Native</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/flutter.html" class="nav-link">Flutter</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/miniprogram.html" class="nav-link">小程序</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/network.html" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/data_structure.html" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/algorithm.html" class="nav-link">算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">常用代码</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/code/easy.html" class="nav-link">LeetCode - 简单</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/medium.html" class="nav-link">LeetCode - 中等</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/difficulty.html" class="nav-link">LeetCode - 困难</a></li></ul></div></div><div class="nav-item"><a href="https://llwanran.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/LLwanran" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/front_end_studying/base/javascript.html" class="active sidebar-link">JS部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#内置类型" class="sidebar-link">内置类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#介绍js有哪些内置对象" class="sidebar-link">介绍js有哪些内置对象</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript有几种类型的值" class="sidebar-link">JavaScript有几种类型的值</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#null，undefined-的区别" class="sidebar-link">null，undefined 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#typeof" class="sidebar-link">Typeof</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#this" class="sidebar-link">This</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈一谈函数中this的指向" class="sidebar-link">谈一谈函数中this的指向</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#与-有什么区别？" class="sidebar-link">==与===有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#break与continue有什么区别？" class="sidebar-link">break与continue有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#void-0和undefined在使用场景上有什么区别" class="sidebar-link">void 0和undefined在使用场景上有什么区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#深浅拷贝" class="sidebar-link">深浅拷贝</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#说说你对作用域链的理解" class="sidebar-link">说说你对作用域链的理解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript原型，原型链-有什么特点？" class="sidebar-link">JavaScript原型，原型链 ? 有什么特点？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#请解释什么是事件代理" class="sidebar-link">请解释什么是事件代理</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript如何实现继承？" class="sidebar-link">Javascript如何实现继承？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#var、let-及-const-区别" class="sidebar-link">var、let 及 const 区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#事件模型" class="sidebar-link">事件模型</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#new操作符具体干了什么呢" class="sidebar-link">new操作符具体干了什么呢?</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#nan是什么-有什么特别之处" class="sidebar-link">NaN是什么? 有什么特别之处?</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#如何把非数值转化为数值" class="sidebar-link">如何把非数值转化为数值?</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#ajax原理" class="sidebar-link">Ajax原理</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#如何解决跨域问题" class="sidebar-link">如何解决跨域问题?</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#模块化" class="sidebar-link">模块化</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#异步加载js的方式有哪些？" class="sidebar-link">异步加载JS的方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#那些操作会造成内存泄漏？" class="sidebar-link">那些操作会造成内存泄漏？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#xml和json的区别？" class="sidebar-link">XML和JSON的区别？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#说说你对amd和commonjs的理解" class="sidebar-link">说说你对AMD和Commonjs的理解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#常见web安全及防护原理" class="sidebar-link">常见web安全及防护原理</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#为什么要有同源限制？" class="sidebar-link">为什么要有同源限制？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别" class="sidebar-link">offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript有哪些方法定义对象" class="sidebar-link">javascript有哪些方法定义对象</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#常见兼容性问题？" class="sidebar-link">常见兼容性问题？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#说你对promise的了解" class="sidebar-link">说你对promise的了解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#你觉得jquery源码有哪些写的好的地方" class="sidebar-link">你觉得jQuery源码有哪些写的好的地方</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#node的应用场景" class="sidebar-link">Node的应用场景</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈谈你对amd、cmd的理解" class="sidebar-link">谈谈你对AMD、CMD的理解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#web开发中会话跟踪的方法有哪些" class="sidebar-link">web开发中会话跟踪的方法有哪些</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#说几条写javascript的基本规范" class="sidebar-link">说几条写JavaScript的基本规范</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript创建对象的几种方式" class="sidebar-link">javascript创建对象的几种方式</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#异步编程的实现方式" class="sidebar-link">异步编程的实现方式</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#eval是做什么的" class="sidebar-link">eval是做什么的</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#_1-2-3-map-parseint-答案是多少" class="sidebar-link">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript-代码中的-use-strict-是什么意思" class="sidebar-link">javascript 代码中的&quot;use strict&quot;;是什么意思</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#json-的了解" class="sidebar-link">JSON 的了解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#同步和异步的区别" class="sidebar-link">同步和异步的区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈谈你对es6的理解" class="sidebar-link">谈谈你对ES6的理解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#ecmascript6-怎么写class么" class="sidebar-link">ECMAScript6 怎么写class么</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#对web标准、可用性、可访问性的理解" class="sidebar-link">对web标准、可用性、可访问性的理解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#如何通过js判断一个数组" class="sidebar-link">如何通过JS判断一个数组</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈一谈let与var的区别" class="sidebar-link">谈一谈let与var的区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#map与foreach的区别" class="sidebar-link">map与forEach的区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈一谈你理解的函数式编程" class="sidebar-link">谈一谈你理解的函数式编程</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈一谈箭头函数与普通函数的区别？" class="sidebar-link">谈一谈箭头函数与普通函数的区别？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#js动画与css动画区别及相应实现" class="sidebar-link">Js动画与CSS动画区别及相应实现</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#js-数组和对象的遍历方式，以及几种方式的比较" class="sidebar-link">JS 数组和对象的遍历方式，以及几种方式的比较</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#gulp是什么" class="sidebar-link">gulp是什么</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#事件的各个阶段" class="sidebar-link">事件的各个阶段</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#let-var-const" class="sidebar-link">let var const</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#正则表达式" class="sidebar-link">正则表达式</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript中callee和caller的作用？" class="sidebar-link">Javascript中callee和caller的作用？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#window-onload和-document-ready" class="sidebar-link">window.onload和$(document).ready</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#addeventlistener-和attachevent-的区别" class="sidebar-link">addEventListener()和attachEvent()的区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生js）" class="sidebar-link">（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#javascript全局函数和全局变量" class="sidebar-link">Javascript全局函数和全局变量</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#项目做过哪些性能优化？" class="sidebar-link">项目做过哪些性能优化？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#浏览器缓存" class="sidebar-link">浏览器缓存</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#防抖-节流" class="sidebar-link">防抖/节流</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#谈谈变量提升？" class="sidebar-link">谈谈变量提升？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/base/javascript.html#defer和async" class="sidebar-link">defer和async</a></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>MVVM</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>常用代码</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="js部分"><a href="#js部分" aria-hidden="true" class="header-anchor">#</a> JS部分</h1> <h2 id="内置类型"><a href="#内置类型" aria-hidden="true" class="header-anchor">#</a> 内置类型</h2> <table><thead><tr><th style="text-align:center">类型种类</th> <th style="text-align:center">访问类型</th> <th style="text-align:center">存储类型</th></tr></thead> <tbody><tr><td style="text-align:center">基本类型</td> <td style="text-align:center">按值访问</td> <td style="text-align:center">栈内存</td></tr> <tr><td style="text-align:center">引用类型</td> <td style="text-align:center">按引用访问</td> <td style="text-align:center">堆内存</td></tr></tbody></table> <ul><li>6种原始类型
<ul><li>Number</li> <li>String</li> <li>Null</li> <li>undefined</li> <li>Boolean</li> <li>Symbol（ES6新定义）</li></ul></li> <li>引用类型
<ul><li>Object</li> <li>Function</li></ul></li></ul> <h3 id="介绍js有哪些内置对象"><a href="#介绍js有哪些内置对象" aria-hidden="true" class="header-anchor">#</a> 介绍js有哪些内置对象</h3> <ul><li><code>Object</code>是<code>JavaScript</code>中所有对象的父对象</li> <li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code></li> <li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li></ul> <h3 id="javascript有几种类型的值"><a href="#javascript有几种类型的值" aria-hidden="true" class="header-anchor">#</a> JavaScript有几种类型的值</h3> <ul><li>栈：原始数据类型（<code>Number</code>、<code>String</code>、<code>Null</code>、<code>Undefined</code>、<code>Boolean</code>、<code>Symbol</code>）</li> <li>堆：引用数据类型（对象、数组和函数）</li> <li>两种类型的区别是：存储位置不同</li> <li>原始数据类型直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li> <li>引用数据类型存储在堆(<code>heap</code>)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li></ul> <h3 id="null，undefined-的区别"><a href="#null，undefined-的区别" aria-hidden="true" class="header-anchor">#</a> null，undefined 的区别</h3> <ul><li><code>undefined</code>表示不存在这个值。</li> <li><code>undefined</code>:是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回<code>undefined</code></li> <li>例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li> <li><code>null</code>表示一个对象被定义了，值为“空值”</li> <li><code>null</code>: 是一个对象(空对象, 没有任何属性和方法)</li> <li>例如作为函数的参数，表示该函数的参数不是对象；</li> <li>在验证<code>null</code>时，一定要使用　<code>===</code>，因为<code>==</code>无法分别<code>null</code>和　<code>undefined</code></li></ul> <h2 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> Typeof</h2> <blockquote><p><code>typeof</code>对于基本类型，除了<code>null</code>都可以显示正确的类型</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment">// 'string'</span>
<span class="token keyword">typeof</span> undefined <span class="token comment">// 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'symbol'</span>
<span class="token keyword">typeof</span> b <span class="token comment">// b 没有声明，但是还会显示 undefined</span>
</code></pre></div><blockquote><p><code>typeof</code>对于对象，除了函数都会显示<code>object</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// 'function'</span>
</code></pre></div><blockquote><p>对于<code>null</code>来说，虽然它是基本类型，但是会显示<code>object</code>，这是一个存在很久了的<code>Bug</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment">// 'object'</span>
</code></pre></div><blockquote><p>PS：为什么会出现这种情况呢？因为在<code>JS</code>的最初版本中，使用的是<code>32</code>位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code>开头代表是对象，然而<code>null</code>表示为全零，所以将它错误的判断为<code>object</code>。虽然现在的内部类型判断代码已经改变了，但是对于这个<code>Bug</code>却是一直流传下来。</p></blockquote> <ul><li>如果我们想获得一个变量的正确类型，可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似<code>[object Type]</code>的字符串</li></ul> <h2 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h2> <p><strong>转Boolean</strong></p> <blockquote><p>在条件判断时，除了<code>undefined</code>，<code>null</code>，<code>false</code>，<code>NaN</code>，<code>''</code>，<code>0</code>，<code>-0</code>，其他所有值都转为<code>true</code>，包括所有对象
<strong>对象转基本类型</strong>
对象在转换基本类型时，首先会调用<code>valueOf</code>然后调用<code>toString</code>。并且这两个方法你是可以重写的</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let a = {
    valueOf() {
    	return 0
    }
}
</code></pre></div><p><strong>四则运算符</strong></p> <blockquote><p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -&gt; '1,2'
// [2, 1].toString() -&gt; '2,1'
// '1,2' + '2,1' = '1,22,1'
</code></pre></div><blockquote><p>对于加号需要注意这个表达式<code>'a' + + 'b'</code></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>'a' + + 'b' // -&gt; &quot;aNaN&quot;
// 因为 + 'b' -&gt; NaN
// 你也许在一些代码中看到过 + '1' -&gt; 1
</code></pre></div><p><strong>== 操作符</strong></p> <blockquote><p>这里来解析一道题目<code>[] == ![] // -&gt; true</code>，下面是这个表达式为何为<code>true</code>的步骤</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// [] 转成 true，然后取反变成 false
[] == false
// 根据第 8 条得出
[] == ToNumber(false)
[] == 0
// 根据第 10 条得出
ToPrimitive([]) == 0
// [].toString() -&gt; ''
'' == 0
// 根据第 6 条得出
0 == 0 // -&gt; true
</code></pre></div><p><strong>比较运算符</strong></p> <ul><li>如果是对象，就通过<code>toPrimitive</code>转换对象</li> <li>如果是字符串，就通过<code>unicode</code>字符索引来比较</li></ul> <h2 id="原型"><a href="#原型" aria-hidden="true" class="header-anchor">#</a> 原型</h2> <ul><li>每个函数都有<code>prototype</code>属性，除了<code>Function.prototype.bind()</code>，该属性指向原型。</li> <li>每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型。其实这个属性指向了<code>[[prototype]]</code>，但是<code>[[prototype]]</code>是内部属性，我们并不能访问到，所以使用<code>_proto_</code>来访问。</li> <li>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code>将对象连接起来组成了原型链</li></ul> <h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> This</h2> <ul><li><code>this</code>总是指向函数的直接调用者（而非间接调用者）</li> <li>如果有<code>new</code>关键字，<code>this</code>指向<code>new</code>出来的那个对象</li> <li>在事件中，<code>this</code>指向触发这个事件的对象，特殊的是，<code>IE</code>中的<code>attachEvent</code>中的<code>this</code>总是指向全局对象<code>Window</code></li></ul> <blockquote><p>我们先来看几个函数调用的场景</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
</code></pre></div><ul><li>对于直接调用<code>foo</code>来说，不管<code>foo</code>函数被放在了什么地方，<code>this</code>一定是<code>window</code></li> <li>对于<code>obj.foo()</code>来说，我们只需要记住，谁调用了函数，谁就是<code>this</code>，所以在这个场景下<code>foo</code>函数中的<code>this</code>就是<code>obj</code>对象</li> <li>对于<code>new</code>的方式来说，<code>this</code>被永远绑定在了<code>c</code>上面，不会被任何方式改变<code>this</code></li></ul> <blockquote><p>说完了以上几种情况，其实很多代码中的<code>this</code>应该就没什么问题了，下面让我们看看箭头函数中的<code>this</code></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function a() {
  return () =&gt; {
    return () =&gt; {
      console.log(this)
    }
  }
}
console.log(a()()())
</code></pre></div><ul><li>首先箭头函数其实是没有<code>this</code>的，箭头函数中的<code>this</code>只取决包裹箭头函数的第一个普通函数的<code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是<code>a</code>，所以此时的<code>this</code>是<code>window</code>。另外对箭头函数使用<code>bind</code>这类函数是无效的。</li> <li>最后种情况也就是<code>bind</code>这些改变上下文的<code>API</code>了，对于这些函数来说，<code>this</code>取决于第一个参数，如果第一个参数为空，那么就是<code>window</code>。</li> <li>那么说到<code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次<code>bind</code>，那么上下文会是什么呢？</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // =&gt; ?
</code></pre></div><blockquote><p>如果你认为输出结果是<code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
</code></pre></div><blockquote><p>可以从上述代码中发现，不管我们给函数<code>bind</code>几次，<code>fn</code>中的<code>this</code>永远由第一次<code>bind</code>决定，所以结果永远是<code>window</code></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let a = { name: 'poetries' }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // =&gt; 'poetries'
</code></pre></div><blockquote><p>以上就是<code>this</code>的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定<code>this</code>最终指向哪里。
首先，<code>new</code>的方式优先级最高，接下来是<code>bind</code>这些函数，然后是<code>obj.foo()</code>这种调用方式，最后是<code>foo</code>这种调用方式，同时，箭头函数的<code>this</code>一旦被绑定，就不会再被任何方式所改变。</p></blockquote> <h3 id="谈一谈函数中this的指向"><a href="#谈一谈函数中this的指向" aria-hidden="true" class="header-anchor">#</a> 谈一谈函数中this的指向</h3> <ul><li>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</li> <li>《javascript语言精髓》中大概概括了4种调用方式：</li> <li>方法调用模式</li> <li>函数调用模式</li> <li>构造器调用模式</li> <li>apply/call调用模式</li></ul> <h2 id="与-有什么区别？"><a href="#与-有什么区别？" aria-hidden="true" class="header-anchor">#</a> ==与===有什么区别？</h2> <ul><li>相等运算符（==）比较两个值是否相等</li> <li>严格相等运算符（===）比较它们是否为“同一个值”</li> <li>如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转化成同一个类型，再用严格相等运算符进行比较。</li></ul> <h2 id="break与continue有什么区别？"><a href="#break与continue有什么区别？" aria-hidden="true" class="header-anchor">#</a> break与continue有什么区别？</h2> <ul><li>break语句用于跳出代码块或循环。</li> <li>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</li></ul> <h2 id="void-0和undefined在使用场景上有什么区别"><a href="#void-0和undefined在使用场景上有什么区别" aria-hidden="true" class="header-anchor">#</a> void 0和undefined在使用场景上有什么区别</h2> <p><strong>void 运算符：</strong>
void 运算符后面接一个表达式，无论表达式的内容是什么，只要跟在void之后都会被调用执行，执行完毕后void操作符返回undefined。使用void 0代替undefined原因如下：</p> <ul><li>兼容性；</li> <li>减少在原形链上查找window.undefined 的时间；</li> <li>避免undefined被误用重新赋值。</li></ul> <h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <ul><li>闭包就是能够读取其他函数内部变量的函数</li> <li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li> <li>闭包的特性：
<ul><li>函数内再嵌套函数</li> <li>内部函数可以引用外层的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收
<strong>说说你对闭包的理解</strong></li></ul></li> <li>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li> <li>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li> <li>闭包的另一个用处，是封装对象的私有属性和私有方法</li> <li><strong>好处</strong>：能够实现封装和缓存等；</li> <li><strong>坏处</strong>：就是消耗内存、不正当使用会造成内存溢出的问题
<strong>使用闭包的注意点</strong></li> <li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</li> <li>解决方法是，在退出函数之前，将不使用的局部变量全部删除</li></ul> <h2 id="深浅拷贝"><a href="#深浅拷贝" aria-hidden="true" class="header-anchor">#</a> 深浅拷贝</h2> <p>**
浅拷贝**</p> <blockquote><p>首先可以通过<code>Object.assign</code>来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code>只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
</code></pre></div><blockquote><p>另外我们还可以通过展开运算符<code>...</code>来实现浅拷贝</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
</code></pre></div><blockquote><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = { ...a }
a.jobs.first = 'native'
console.log(b.jobs.first) // native
</code></pre></div><blockquote><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。
<strong>深拷贝</strong>
这个问题通常可以通过<code>JSON.parse(JSON.stringify(object))</code>来解决。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
</code></pre></div><p><strong>但是该方法也是有局限性的</strong>：</p> <ul><li>会忽略<code>undefined</code></li> <li>会忽略<code>symbol</code></li> <li>不能序列化函数</li> <li>不能解决循环引用的对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj)
</code></pre></div><h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" aria-hidden="true" class="header-anchor">#</a> 说说你对作用域链的理解</h2> <ul><li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li> <li>简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li></ul> <h2 id="javascript原型，原型链-有什么特点？"><a href="#javascript原型，原型链-有什么特点？" aria-hidden="true" class="header-anchor">#</a> JavaScript原型，原型链 ? 有什么特点？</h2> <ul><li>每个对象都会在其内部初始化一个属性，就是<code>prototype</code>(原型)，当我们访问一个对象的属性时</li> <li>如果这个对象内部不存在这个属性，那么他就会去<code>prototype</code>里找这个属性，这<code>个prototype</code>又会有自己的<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li> <li>关系：<code>instance.constructor.prototype = instance.__proto__</code></li> <li>特点：
<ul><li><code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li></ul></li> <li>当我们需要一个属性的时，<code>Javascript</code>引擎会先看当前对象中是否有这个属性， 如果没有的</li> <li>就会查找他的<code>Prototype</code>对象是否有这个属性，如此递推下去，一直检索到<code>Object</code>内建对象</li></ul> <h2 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" aria-hidden="true" class="header-anchor">#</a> 请解释什么是事件代理</h2> <ul><li>事件代理（<code>Event Delegation</code>），又称之为事件委托。是<code>JavaScript</code>中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li> <li>可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li> <li>可以实现当新增子对象时无需再次对其绑定</li></ul> <h2 id="javascript如何实现继承？"><a href="#javascript如何实现继承？" aria-hidden="true" class="header-anchor">#</a> Javascript如何实现继承？</h2> <ul><li>构造继承</li> <li>原型继承</li> <li>实例继承</li> <li>拷贝继承</li> <li>原型<code>prototype</code>机制或<code>apply</code>和<code>call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wang'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//继承了Parent，通过原型</span>

    <span class="token keyword">var</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>demo<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>demo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//得到被继承的属性</span>
  <span class="token punctuation">}</span>
</code></pre></div><h2 id="var、let-及-const-区别"><a href="#var、let-及-const-区别" aria-hidden="true" class="header-anchor">#</a> var、let 及 const 区别</h2> <blockquote><p>涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？</p></blockquote> <ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li> <li><code>var</code>存在提升，我们能在声明之前使用。<code>let</code>、<code>const</code>因为暂时性死区的原因，不能在声明前使用</li> <li><code>var</code>在全局作用域下声明变量会导致变量挂载在<code>window</code>上，其他两者不会</li> <li><code>let</code>和<code>const</code>作用基本一致，但是后者声明的变量不能再次赋值</li></ul> <h2 id="事件模型"><a href="#事件模型" aria-hidden="true" class="header-anchor">#</a> 事件模型</h2> <blockquote><p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p></blockquote> <ul><li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li> <li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li> <li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li> <li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation（）</code>方法；在IE下设置<code>cancelBubble = true</code></li> <li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault（）</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li></ul> <h2 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" aria-hidden="true" class="header-anchor">#</a> new操作符具体干了什么呢?</h2> <ul><li>创建一个空对象，并且<code>this</code>变量引用该对象，同时还继承了该函数的原型</li> <li>属性和方法被加入到<code>this</code>引用的对象中</li> <li>新创建的对象由<code>this</code>所引用，并且最后隐式的返回<code>this</code></li></ul> <h2 id="nan是什么-有什么特别之处"><a href="#nan是什么-有什么特别之处" aria-hidden="true" class="header-anchor">#</a> NaN是什么? 有什么特别之处?</h2> <p>NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p> <ul><li>NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number；</li> <li>NaN不等于任何值，包括它本身；</li> <li>NaN与任何数（包括它自己）的运算，得到的都是NaN。</li></ul> <h2 id="如何把非数值转化为数值"><a href="#如何把非数值转化为数值" aria-hidden="true" class="header-anchor">#</a> 如何把非数值转化为数值?</h2> <ul><li>Number()</li> <li>parseInt()</li> <li>parseFloat()</li> <li>数值运算符（Convert to number）：+x</li> <li>负数值运算符（Negate）：-x</li></ul> <h2 id="ajax原理"><a href="#ajax原理" aria-hidden="true" class="header-anchor">#</a> Ajax原理</h2> <ul><li><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascript</code>来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li> <li><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>ajax</code>的核心机制</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 1. 创建连接</span>
  <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 2. 连接服务器</span>
  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 第三个参数为true，表示该请求应该以异步模式执行</span>
  <span class="token comment">// 3. 发送请求</span>
  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 4. 接受请求</span>
  xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">success</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// fail</span>
        fail <span class="token operator">&amp;&amp;</span> <span class="token function">fail</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p><strong>ajax 有那些优缺点?</strong></p> <ul><li>优点：
<ul><li>通过异步模式，提升了用户体验.</li> <li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li> <li><code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li> <li><code>Ajax</code>可以实现动态不刷新（局部刷新）</li></ul></li> <li>缺点：
<ul><li>安全问题<code>AJAX</code>暴露了与服务器交互的细节。</li> <li>对搜索引擎的支持比较弱。</li> <li>不容易调试。</li></ul></li></ul> <h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" aria-hidden="true" class="header-anchor">#</a> 如何解决跨域问题?</h2> <blockquote><p>首先了解下浏览器的同源策略 同源策略<code>/SOP（Same origin policy）</code>是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。所谓同源是指&quot;<strong>协议+域名+端口</strong>&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源</p></blockquote> <p><strong>那么怎样解决跨域问题的呢？</strong></p> <ul><li><strong>通过jsonp跨域</strong></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>

<span class="token comment">// 传参并指定回调执行函数为onBack</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://www.....:8080/login?user=admin&amp;callback=onBack'</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 回调执行函数</span>
<span class="token keyword">function</span> <span class="token function">onBack</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>jsonp的原理</p> <ul><li>首先是利用script标签的src属性来实现跨域</li> <li>通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信</li> <li>由于使用script标签的src属性，因此只支持get方法</li></ul></blockquote> <ul><li><strong>document.domain + iframe跨域</strong></li></ul> <blockquote><p>此方案仅限主域相同，子域不同的跨域应用场景</p></blockquote> <ol><li>父窗口：</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>iframe<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://child.domain.com/b.html<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
  document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token string">'admin'</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>子窗口：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span>
<span class="token comment">// 获取父窗口中变量</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'get js data from parent ---&gt; '</span> <span class="token operator">+</span> window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>cors</strong></li> <li><strong>postMessage</strong></li> <li><strong>websocket</strong></li> <li><strong>nginx代理跨域</strong></li> <li><strong>nodejs中间件代理跨域</strong></li></ul> <h2 id="模块化"><a href="#模块化" aria-hidden="true" class="header-anchor">#</a> 模块化</h2> <blockquote><p>涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？
使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处</p></blockquote> <ul><li>解决命名冲突</li> <li>提供复用性</li> <li>提高代码可维护性
<strong>立即执行函数</strong></li></ul> <blockquote><p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
</code></pre></div><p><strong>AMD 和 CMD</strong></p> <blockquote><p>鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
</code></pre></div><p><strong>CommonJS</strong></p> <blockquote><p><code>CommonJS</code>最早是<code>Node</code>在使用，目前也仍然广泛使用，比如在<code>Webpack</code>中你就能见到它，当然目前在<code>Node</code>中的模块管理已经和<code>CommonJS</code>有一些区别了</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -&gt; log 1
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>ar module = require('./a.js')
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
</code></pre></div><blockquote><p>另外虽然<code>exports</code>和<code>module.exports</code>用法相似，但是不能对<code>exports</code>直接赋值。因为<code>var exports = module.exports</code>这句代码表明了<code>exports</code>和<code>module.exports</code>享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对<code>exports</code>赋值就会导致两者不再指向同一个内存地址，修改并不会对<code>module.exports</code>起效
<strong>ES Module</strong> <code>ES Module</code>是原生实现的模块化方案，与<code>CommonJS</code>有以下几个区别</p></blockquote> <ol><li><code>CommonJS</code>支持动态导入，也就是<code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li> <li><code>CommonJS</code>是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li> <li><code>CommonJS</code>在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是<code>ES Module</code>采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li> <li><code>ES Module</code>会编译成<code>require/exports</code>来执行的</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
</code></pre></div><h2 id="异步加载js的方式有哪些？"><a href="#异步加载js的方式有哪些？" aria-hidden="true" class="header-anchor">#</a> 异步加载JS的方式有哪些？</h2> <ul><li>defer，只支持<code>IE</code></li> <li><code>async</code>：</li> <li>创建<code>script</code>，插入到<code>DOM</code>中，加载完毕后<code>callBack</code></li></ul> <h2 id="那些操作会造成内存泄漏？"><a href="#那些操作会造成内存泄漏？" aria-hidden="true" class="header-anchor">#</a> 那些操作会造成内存泄漏？</h2> <ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li> <li><code>setTimeout</code>的第一个参数使用字符串而非函数的话，会引发内存泄漏</li> <li>闭包使用不当</li></ul> <h2 id="xml和json的区别？"><a href="#xml和json的区别？" aria-hidden="true" class="header-anchor">#</a> XML和JSON的区别？</h2> <ul><li>数据体积方面
<ul><li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li></ul></li> <li>数据交互方面
<ul><li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li></ul></li> <li>数据描述方面
<ul><li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li></ul></li> <li>传输速度方面
<ul><li><code>JSON</code>的速度要远远快于<code>XML</code></li></ul></li></ul> <h2 id="说说你对amd和commonjs的理解"><a href="#说说你对amd和commonjs的理解" aria-hidden="true" class="header-anchor">#</a> 说说你对AMD和Commonjs的理解</h2> <ul><li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li> <li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li></ul> <h2 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" aria-hidden="true" class="header-anchor">#</a> 常见web安全及防护原理</h2> <ul><li><p><code>sql</code>注入原理</p> <ul><li>就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li></ul></li> <li><p>总的来说有以下几点</p> <ul><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li> <li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li> <li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li> <li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息
<strong>XSS原理及防范</strong></li></ul></li> <li><p><code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点
<strong>XSS防范方法</strong></p></li> <li><p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code>弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击
<strong>XSS与CSRF有什么区别吗？</strong></p></li> <li><p><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</p></li> <li><p>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></p></li> <li><p>在不登出<code>A</code>的情况下，访问危险网站<code>B</code> <strong>CSRF的防御</strong></p></li> <li><p>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</p></li> <li><p>通过验证码的方法</p></li></ul> <h2 id="为什么要有同源限制？"><a href="#为什么要有同源限制？" aria-hidden="true" class="header-anchor">#</a> 为什么要有同源限制？</h2> <ul><li>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li> <li>举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</li></ul> <h2 id="offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别"><a href="#offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别" aria-hidden="true" class="header-anchor">#</a> offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h2> <ul><li><code>offsetWidth/offsetHeight</code>返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li> <li><code>clientWidth/clientHeight</code>返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li> <li><code>scrollWidth/scrollHeight</code>返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li></ul> <h2 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" aria-hidden="true" class="header-anchor">#</a> javascript有哪些方法定义对象</h2> <ul><li>对象字面量：<code>var obj = {};</code></li> <li>构造函数：<code>var obj = new Object();</code></li> <li>Object.create():<code>var obj = Object.create(Object.prototype);</code></li></ul> <h2 id="常见兼容性问题？"><a href="#常见兼容性问题？" aria-hidden="true" class="header-anchor">#</a> 常见兼容性问题？</h2> <ul><li><code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></li> <li>浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*{margin:0;padding:0;}</code>来统一,，但是全局效率很低，一般是如下这样解决：</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p</span><span class="token punctuation">{</span>
<span class="token property">margin</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
<span class="token property">padding</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</li> <li><code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</li></ul> <h2 id="说你对promise的了解"><a href="#说你对promise的了解" aria-hidden="true" class="header-anchor">#</a> 说你对promise的了解</h2> <ul><li>依照<code>Promise/A+</code>的定义，<code>Promise</code>有四种状态：
<ul><li><code>pending:</code>初始状态, 非<code>fulfilled</code>或<code>rejected.</code></li> <li><code>fulfilled:</code>成功的操作.</li> <li><code>rejected:</code>失败的操作.</li> <li><code>settled: Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li></ul></li> <li>另外，<code>fulfilled</code>与<code>rejected</code>一起合称<code>settled</code></li> <li><code>Promise</code>对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code>) 计算
<strong>Promise 的构造函数</strong></li> <li>构造一个<code>Promise</code>，最基本的用法如下：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// succeed</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token comment">// fails</span>
            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token function">Error</span><span class="token punctuation">(</span>errMessage<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>Promise</code>实例拥有<code>then</code>方法（具有<code>then</code>方法的对象，通常被称为<code>thenable</code>）。它的使用方法如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>promise.then(onFulfilled, onRejected)
</code></pre></div><ul><li>接收两个函数作为参数，一个在<code>fulfilled</code>的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是<code>future</code>，<code>onFulfilled</code>对应<code>resolve</code>,<code>onRejected</code>对应<code>reject</code></li></ul> <h2 id="你觉得jquery源码有哪些写的好的地方"><a href="#你觉得jquery源码有哪些写的好的地方" aria-hidden="true" class="header-anchor">#</a> 你觉得jQuery源码有哪些写的好的地方</h2> <ul><li><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li> <li><code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li> <li>有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li> <li><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li></ul> <h2 id="node的应用场景"><a href="#node的应用场景" aria-hidden="true" class="header-anchor">#</a> Node的应用场景</h2> <ul><li>特点：
<ul><li>1、它是一个<code>Javascript</code>运行环境</li> <li>2、依赖于<code>Chrome V8</code>引擎进行代码解释</li> <li>3、事件驱动</li> <li>4、非阻塞<code>I/O</code></li> <li>5、单进程，单线程</li></ul></li> <li>优点：
<ul><li>高并发（最重要的优点）</li></ul></li> <li>缺点：
<ul><li>1、只支持单<code>核CPU</code>，不能充分利用<code>CPU</code></li> <li>2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li></ul></li></ul> <h2 id="谈谈你对amd、cmd的理解"><a href="#谈谈你对amd、cmd的理解" aria-hidden="true" class="header-anchor">#</a> 谈谈你对AMD、CMD的理解</h2> <ul><li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li> <li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的
<strong>es6模块 commonjs amd cmd</strong></li> <li><code>CommonJS</code>的规范中，每个<code>JavaScript</code>文件就是一个独立的模块上下文（<code>module context</code>），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</li> <li><code>CommonJS</code>是同步加载模块,在浏览器中会出现堵塞情况，所以不适用</li> <li><code>AMD</code>异步，需要定义回调<code>define</code>方式</li> <li><code>es6</code>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量
<code>es6</code>还可以导出类、方法，自动适用严格模式</li></ul> <h2 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" aria-hidden="true" class="header-anchor">#</a> web开发中会话跟踪的方法有哪些</h2> <ul><li><code>cookie</code></li> <li><code>session</code></li> <li><code>url</code>重写</li> <li>隐藏<code>input</code></li> <li><code>ip</code>地址</li></ul> <h2 id="说几条写javascript的基本规范"><a href="#说几条写javascript的基本规范" aria-hidden="true" class="header-anchor">#</a> 说几条写JavaScript的基本规范</h2> <ul><li>不要在同一行声明多个变量</li> <li>请使用<code>===/!==</code>来比较<code>true/false</code>或者数值</li> <li>使用对象字面量替代<code>new Array</code>这种形式</li> <li>不要使用全局函数</li> <li><code>Switch</code>语句必须带有<code>default</code>分支</li> <li><code>If</code>语句必须使用大括号</li> <li><code>for-in</code>循环中的变量 应该使用<code>var</code>关键字明确限定作用域，从而避免作用域污</li></ul> <h2 id="javascript创建对象的几种方式"><a href="#javascript创建对象的几种方式" aria-hidden="true" class="header-anchor">#</a> javascript创建对象的几种方式</h2> <blockquote><p><code>javascript</code>创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用<code>JSON</code>；但写法有很多种，也能混合使用</p></blockquote> <ul><li>对象字面量的方式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>person<span class="token operator">=</span><span class="token punctuation">{</span>firstname<span class="token punctuation">:</span><span class="token string">&quot;Mark&quot;</span><span class="token punctuation">,</span>lastname<span class="token punctuation">:</span><span class="token string">&quot;Yun&quot;</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">25</span><span class="token punctuation">,</span>eyecolor<span class="token punctuation">:</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>用<code>function</code>来模拟无参的构造函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">var</span> person<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span>
        person<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Mark&quot;</span><span class="token punctuation">;</span>
        person<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">&quot;25&quot;</span><span class="token punctuation">;</span>
        person<span class="token punctuation">.</span><span class="token function-variable function">work</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">&quot; hello...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
person<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>用<code>function</code>来模拟参构造函数来实现（用<code>this</code>关键字定义构造的上下文属性）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Pet</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>hobby<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token comment">//this作用域：当前对象</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token operator">=</span>hobby<span class="token punctuation">;</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">eat</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">&quot;,我喜欢&quot;</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token operator">+</span><span class="token string">&quot;,是个程序员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> maidou <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Pet</span><span class="token punctuation">(</span><span class="token string">&quot;麦兜&quot;</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token string">&quot;coding&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实例化、创建对象</span>
    maidou<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用eat方法</span>
</code></pre></div><ul><li>用工厂方式来创建（内置对象）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> wcDog <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     wcDog<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;旺财&quot;</span><span class="token punctuation">;</span>
     wcDog<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
     wcDog<span class="token punctuation">.</span><span class="token function-variable function">work</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;我是&quot;</span><span class="token operator">+</span>wcDog<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">&quot;,汪汪汪......&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     wcDog<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>用原型方式来创建</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

     <span class="token punctuation">}</span>
     Dog<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;旺财&quot;</span><span class="token punctuation">;</span>
     Dog<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">&quot;是个吃货&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">var</span> wangcai <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     wangcai<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>用混合方式来创建</li></ul> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>price<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token operator">=</span>price<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     Car<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sell</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;我是&quot;</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">&quot;，我现在卖&quot;</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token operator">+</span><span class="token string">&quot;万元&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">var</span> camry <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">&quot;凯美瑞&quot;</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    camry<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="异步编程的实现方式"><a href="#异步编程的实现方式" aria-hidden="true" class="header-anchor">#</a> 异步编程的实现方式</h2> <ul><li>回调函数
<ul><li>优点：简单、容易理解</li> <li>缺点：不利于维护，代码耦合高</li></ul></li> <li>事件监听(采用时间驱动模式，取决于某个事件是否发生)：
<ul><li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li> <li>缺点：事件驱动型，流程不够清晰</li></ul></li> <li>发布/订阅(观察者模式)
<ul><li>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li></ul></li> <li>Promise对象
<ul><li>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li> <li>缺点：编写和理解，相对比较难</li></ul></li> <li>Generator函数
<ul><li>优点：函数体内外的数据交换、错误处理机制</li> <li>缺点：流程管理不方便</li></ul></li> <li>async函数
<ul><li>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li> <li>缺点：错误处理机制</li></ul></li></ul> <h2 id="eval是做什么的"><a href="#eval是做什么的" aria-hidden="true" class="header-anchor">#</a> eval是做什么的</h2> <ul><li>它的功能是把对应的字符串解析成<code>JS</code>代码并运行</li> <li>应该避免使用<code>eval</code>，不安全，非常耗性能（<code>2</code>次，一次解析成<code>js</code>语句，一次执行）</li> <li>由<code>JSON</code>字符串转换为JSON对象的时候可以用<code>eval，var obj =eval('('+ str +')')</code></li></ul> <h2 id="_1-2-3-map-parseint-答案是多少"><a href="#_1-2-3-map-parseint-答案是多少" aria-hidden="true" class="header-anchor">#</a> [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少</h2> <ul><li><code>[1, NaN, NaN]</code>因为<code>parseInt</code>需要两个参数<code>(val, radix)</code>，其中<code>radix</code>表示解析时用的基数。</li> <li><code>map</code>传了<code>3</code>个<code>(element, index, array)</code>，对应的<code>radix</code>不合法导致解析失败。</li></ul> <h2 id="javascript-代码中的-use-strict-是什么意思"><a href="#javascript-代码中的-use-strict-是什么意思" aria-hidden="true" class="header-anchor">#</a> javascript 代码中的&quot;use strict&quot;;是什么意思</h2> <ul><li><code>use strict</code>是一种<code>ECMAscript 5</code>添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li></ul> <h2 id="json-的了解"><a href="#json-的了解" aria-hidden="true" class="header-anchor">#</a> JSON 的了解</h2> <ul><li><code>JSON(JavaScript Object Notation)</code>是一种轻量级的数据交换格式</li> <li>它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li> <li><code>JSON</code>字符串转换为JSON对象:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'('</span><span class="token operator">+</span> str <span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">parseJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>JSON</code>对象转换为JSON字符串：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var last=obj.toJSONString();
var last=JSON.stringify(obj);
</code></pre></div><h2 id="同步和异步的区别"><a href="#同步和异步的区别" aria-hidden="true" class="header-anchor">#</a> 同步和异步的区别</h2> <ul><li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li> <li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li></ul> <h2 id="谈谈你对es6的理解"><a href="#谈谈你对es6的理解" aria-hidden="true" class="header-anchor">#</a> 谈谈你对ES6的理解</h2> <ul><li>新增模板字符串（为<code>JavaScript</code>提供了简单的字符串插值功能）</li> <li>箭头函数</li> <li><code>for-of</code>（用来遍历数据—例如数组中的值。）</li> <li><code>arguments</code>对象可被不定参数和默认参数完美代替。</li> <li><code>ES6</code>将p<code>romise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。</li> <li>增加了<code>let</code>和<code>const</code>命令，用来声明变量。</li> <li>增加了块级作用域。</li> <li><code>let</code>命令实际上就增加了块级作用域。</li> <li>还有就是引入<code>module</code>模块的概念</li></ul> <h2 id="ecmascript6-怎么写class么"><a href="#ecmascript6-怎么写class么" aria-hidden="true" class="header-anchor">#</a> ECMAScript6 怎么写class么</h2> <ul><li>这个语法糖可以让有<code>OOP</code>基础的人更快上手<code>js</code>，至少是一个官方的实现了</li> <li>但对熟悉<code>js</code>的人来说，这个东西没啥大影响；一个<code>Object.creat()</code>搞定继承，比<code>class</code>简洁清晰的多</li></ul> <h2 id="对web标准、可用性、可访问性的理解"><a href="#对web标准、可用性、可访问性的理解" aria-hidden="true" class="header-anchor">#</a> 对web标准、可用性、可访问性的理解</h2> <ul><li>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</li> <li>可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性</li> <li>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</li></ul> <h2 id="如何通过js判断一个数组"><a href="#如何通过js判断一个数组" aria-hidden="true" class="header-anchor">#</a> 如何通过JS判断一个数组</h2> <p>1、<code>instanceof</code>操作符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><blockquote><p>arr instanceof Array的含义是：判断Array的prorotype属性是不是在arr的原型链上，是返回true,否返回false;</p></blockquote> <p>2、对象的<code>constructor</code>属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><blockquote><p>除了instanceof，每个对象还有constructor的属性，利用它似乎也能进行Array的判断</p></blockquote> <ul><li>instanceof 和 constructor 的缺陷</li></ul> <blockquote><p>由于每个iframe都有一套自己的执行环境，跨frame实例化的对象彼此是不共享原型链的，因此导致<code>instanceof</code>和<code>constructor</code>失效。</p></blockquote> <p>3、<code>Object.prototype.toString</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isArrayFn</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isArrayFn</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><ul><li>取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于&quot;[object Array]&quot;的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)</li> <li>利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的</li> <li>JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String</li></ul> <p>4、<code>Array.isArray()</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><ul><li>ECMAScript5中引入了Array.isArray()方法，用于专门判断一个对象是不是数组，是返回true，不是返回false；目前所有主流浏览器和IE9+都对其进行了支持，IE8及以下浏览器不支持该方法</li></ul> <h2 id="谈一谈let与var的区别"><a href="#谈一谈let与var的区别" aria-hidden="true" class="header-anchor">#</a> 谈一谈let与var的区别</h2> <ul><li><code>let</code>命令不存在变量提升，如果在<code>let</code>前使用，会导致报错</li> <li>如果块区中存在<code>let</code>和<code>const</code>命令，就会形成封闭作用域</li> <li>不允许重复声明，因此，不能在函数内部重新声明参数</li></ul> <h2 id="map与foreach的区别"><a href="#map与foreach的区别" aria-hidden="true" class="header-anchor">#</a> map与forEach的区别</h2> <ul><li><code>forEach</code>方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容<code>item</code>、数组索引<code>index</code>、和当前遍历数组<code>Array</code></li> <li><code>map</code>方法，基本用法与<code>forEach</code>一致，但是不同的，它会返回一个新的数组，所以在callback需要有<code>return</code>值，如果没有，会返回<code>undefined</code></li></ul> <h2 id="谈一谈你理解的函数式编程"><a href="#谈一谈你理解的函数式编程" aria-hidden="true" class="header-anchor">#</a> 谈一谈你理解的函数式编程</h2> <ul><li>简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论</li> <li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;</li></ul> <h2 id="谈一谈箭头函数与普通函数的区别？"><a href="#谈一谈箭头函数与普通函数的区别？" aria-hidden="true" class="header-anchor">#</a> 谈一谈箭头函数与普通函数的区别？</h2> <ul><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li> <li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li> <li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替</li> <li>不可以使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</li></ul> <h2 id="js动画与css动画区别及相应实现"><a href="#js动画与css动画区别及相应实现" aria-hidden="true" class="header-anchor">#</a> Js动画与CSS动画区别及相应实现</h2> <ul><li><code>CSS3</code>的动画的优点
<ul><li>在性能上会稍微好一些，浏览器会对<code>CSS3</code>的动画做一些优化</li> <li>代码相对简单</li></ul></li> <li>缺点
<ul><li>在动画控制上不够灵活</li> <li>兼容性不好</li></ul></li> <li><code>JavaScript</code>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容<code>IE6</code>，并且功能强大。对于一些复杂控制的动画，使用<code>javascript</code>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑<code>CSS</code>吧</li></ul> <h2 id="js-数组和对象的遍历方式，以及几种方式的比较"><a href="#js-数组和对象的遍历方式，以及几种方式的比较" aria-hidden="true" class="header-anchor">#</a> JS 数组和对象的遍历方式，以及几种方式的比较</h2> <blockquote><p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历</p></blockquote> <ul><li><code>for in</code>循环</li> <li><code>for</code>循环</li> <li><code>forEach</code> <ul><li>这里的<code>forEach</code>回调中两个参数分别为<code>value</code>，<code>index</code></li> <li><code>forEach</code>无法遍历对象</li> <li>IE不支持该方法；<code>Firefox</code>和<code>chrome</code>支持</li> <li><code>forEach</code>无法使用<code>break</code>，<code>continue</code>跳出循环，且使用<code>return</code>是跳过本次循环</li></ul></li> <li>这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题</li> <li>在方式一中，<code>for-in</code>需要分析出<code>array</code>的每个属性，这个操作性能开销很大。用在<code>key</code>已知的数组上是非常不划算的。所以尽量不要用<code>for-in</code>，除非你不清楚要处理哪些属性，例如<code>JSON</code>对象这样的情况</li> <li>在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当<code>array</code>里存放的都是<code>DOM</code>元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li></ul> <h2 id="gulp是什么"><a href="#gulp是什么" aria-hidden="true" class="header-anchor">#</a> gulp是什么</h2> <ul><li><code>gulp</code>是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成</li> <li>Gulp的核心概念：流</li> <li>流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向</li> <li>gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作</li> <li>Gulp的特点：
<ul><li><strong>易于使用</strong>：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理</li> <li><strong>构建快速</strong>利用<code>Node.js</code>流的威力，你可以快速构建项目并减少频繁的<code>IO</code>操作</li> <li><strong>易于学习</strong>通过最少的<code>API</code>，掌握<code>gulp</code>毫不费力，构建工作尽在掌握：如同一系列流管道</li></ul></li></ul> <h2 id="事件的各个阶段"><a href="#事件的各个阶段" aria-hidden="true" class="header-anchor">#</a> 事件的各个阶段</h2> <ul><li>1：捕获阶段 ---&gt; 2：目标阶段 ---&gt; 3：冒泡阶段</li> <li><code>document</code>---&gt;<code>target</code>目标 ----&gt;<code>document</code></li> <li>由此，<code>addEventListener</code>的第三个参数设置为<code>true</code>和<code>false</code>的区别已经非常清晰了
<ul><li><code>true</code>表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件</li> <li><code>false</code>表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</li></ul></li></ul> <h2 id="let-var-const"><a href="#let-var-const" aria-hidden="true" class="header-anchor">#</a> let var const</h2> <p><strong>let</strong></p> <ul><li>允许你声明一个作用域被限制在块级中的变量、语句或者表达式</li> <li>let绑定不受变量提升的约束，这意味着let声明不会被提升到当前</li> <li>该变量处于从块开始到初始化处理的“暂存死区”
<strong>var</strong></li> <li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li> <li>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明
<strong>const</strong></li> <li>声明创建一个值的只读引用 (即指针)</li> <li>基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成<code>const</code>申明基本数据类型时</li> <li>再将其值改变时，将会造成报错， 例如<code>const a = 3</code>;<code>a = 5</code>时 将会报错</li> <li>但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</li></ul> <h2 id="正则表达式"><a href="#正则表达式" aria-hidden="true" class="header-anchor">#</a> 正则表达式</h2> <blockquote><p>正则表达式构造函数<code>var reg=new RegExp(“xxx”)</code>与正则表达字面量<code>var reg=//</code>有什么不同？匹配邮箱的正则表达式？</p></blockquote> <ul><li>当使用<code>RegExp()</code>构造函数的时候，不仅需要转义引号（即<code>\</code>”表示”），并且还需要双反斜杠（即<code>\\</code>表示一个<code>\</code>）。使用正则表达字面量的效率更高
邮箱的正则匹配：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> regMail <span class="token operator">=</span> <span class="token regex">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="javascript中callee和caller的作用？"><a href="#javascript中callee和caller的作用？" aria-hidden="true" class="header-anchor">#</a> Javascript中callee和caller的作用？</h2> <ul><li><code>caller</code>是返回一个对函数的引用，该函数调用了当前函数；</li> <li><code>callee</code>是返回正在被执行的<code>function</code>函数，也就是所指定的<code>function</code>对象的正文</li></ul> <blockquote><p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用<code>callee</code>完成）</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//典型的斐波那契数列</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  <span class="token keyword">return</span> result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                 <span class="token comment">//argument.callee()表示fn()</span>
                 result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>arguments<span class="token punctuation">.</span><span class="token function">callee</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>arguments<span class="token punctuation">.</span><span class="token function">callee</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token keyword">return</span> result<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre></div><h2 id="window-onload和-document-ready"><a href="#window-onload和-document-ready" aria-hidden="true" class="header-anchor">#</a> window.onload和$(document).ready</h2> <blockquote><p>原生<code>JS</code>的<code>window.onload</code>与<code>Jquery</code>的<code>$(document).ready(function(){})</code>有什么不同？如何用原生JS实现Jq的<code>ready</code>方法？</p></blockquote> <ul><li><code>window.onload()</code>方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</li> <li><code>$(document).ready()</code>是<code>DOM</code>结构绘制完毕后就执行，不必等到加载完毕</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ready</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//标准浏览器</span>
          document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">//注销事件, 避免反复触发</span>
              document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//执行函数</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//IE</span>
          document<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'onreadystatechange'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token string">'complete'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                 document<span class="token punctuation">.</span><span class="token function">detachEvent</span><span class="token punctuation">(</span><span class="token string">'onreadystatechange'</span><span class="token punctuation">,</span> arguments<span class="token punctuation">.</span>callee<span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//函数执行</span>
             <span class="token punctuation">}</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="addeventlistener-和attachevent-的区别"><a href="#addeventlistener-和attachevent-的区别" aria-hidden="true" class="header-anchor">#</a> addEventListener()和attachEvent()的区别</h2> <ul><li><code>addEventListener()</code>是符合W3C规范的标准方法;<code>attachEvent()</code>是IE低版本的非标准方法</li> <li><code>addEventListener()</code>支持事件冒泡和事件捕获; - 而<code>attachEvent()</code>只支持事件冒泡</li> <li><code>addEventListener()</code>的第一个参数中,事件类型不需要添加<code>on</code>;<code>attachEvent()</code>需要添加<code>'on'</code></li> <li>如果为同一个元素绑定多个事件,<code>addEventListener()</code>会按照事件绑定的顺序依次执行,<code>attachEvent()</code>会按照事件绑定的顺序倒序执行</li></ul> <h2 id="（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生js）"><a href="#（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生js）" aria-hidden="true" class="header-anchor">#</a> （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h2> <ul><li>给需要拖拽的节点绑定<code>mousedown</code>,<code>mousemove</code>,<code>mouseup</code>事件</li> <li><code>mousedown</code>事件触发后，开始拖拽</li> <li><code>mousemove</code>时，需要通过<code>event.clientX</code>和<code>clientY</code>获取拖拽位置，并实时更新位置</li> <li><code>mouseup</code>时，拖拽结束</li> <li>需要注意浏览器边界的情况</li></ul> <h2 id="javascript全局函数和全局变量"><a href="#javascript全局函数和全局变量" aria-hidden="true" class="header-anchor">#</a> Javascript全局函数和全局变量</h2> <p><strong>全局变量</strong></p> <ul><li><code>Infinity</code>代表正的无穷大的数值。</li> <li><code>NaN</code>指示某个值是不是数字值。</li> <li><code>undefined</code>指示未定义的值。
<strong>全局函数</strong></li> <li><code>decodeURI()</code>解码某个编码的<code>URI</code>。</li> <li><code>decodeURIComponent()</code>解码一个编码的<code>URI</code>组件。</li> <li>`encodeURI() 把字符串编码为 URI。</li> <li><code>encodeURIComponent()</code>把字符串编码为<code>URI</code>组件。</li> <li><code>escape()</code>对字符串进行编码。</li> <li><code>eval()</code>计算<code>JavaScript</code>字符串，并把它作为脚本代码来执行。</li> <li><code>isFinite()</code>检查某个值是否为有穷大的数。</li> <li><code>isNaN()</code>检查某个值是否是数字。</li> <li><code>Number()</code>把对象的值转换为数字。</li> <li><code>parseFloat()</code>解析一个字符串并返回一个浮点数。</li> <li><code>parseInt()</code>解析一个字符串并返回一个整数。</li> <li><code>String()</code>把对象的值转换为字符串。</li> <li><code>unescape()</code>对由<code>escape()</code>编码的字符串进行解码</li></ul> <h2 id="项目做过哪些性能优化？"><a href="#项目做过哪些性能优化？" aria-hidden="true" class="header-anchor">#</a> 项目做过哪些性能优化？</h2> <ul><li>减少 HTTP` 请求数</li> <li>减少<code>DNS</code>查询</li> <li>使用<code>CDN</code></li> <li>避免重定向</li> <li>图片懒加载</li> <li>减少<code>DOM</code>元素数量</li> <li>减少<code>DOM</code>操作</li> <li>使用外部<code>JavaScript</code>和<code>CSS</code></li> <li>压缩<code>JavaScript</code>、<code>CSS</code>、字体、图片等</li> <li>优化<code>CSS Sprite</code></li> <li>使用<code>iconfont</code></li> <li>字体裁剪</li> <li>多域名分发划分内容到不同域名</li> <li>尽量减少<code>iframe</code>使用</li> <li>避免图片<code>src</code>为空</li> <li>把样式表放在<code>link</code>中</li> <li>把脚本放在页面底部</li></ul> <h2 id="浏览器缓存"><a href="#浏览器缓存" aria-hidden="true" class="header-anchor">#</a> 浏览器缓存</h2> <blockquote><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p></blockquote> <ul><li>先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li> <li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li> <li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
区别是，强缓存不对发送请求到服务器，但协商缓存会。</li> <li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li> <li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li> <li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；
<strong>强缓存</strong></li> <li><code>Expires</code>（该字段是<code>http1.0</code>时的规范，值为一个绝对时间的<code>GMT</code>格式的时间字符串，代表缓存资源的过期时间）</li> <li><code>Cache-Control:max-age</code>（该字段是<code>http1.1</code>的规范，强缓存利用其<code>max-age</code>值来判断缓存资源的最大生命周期，它的值单位为秒）
<strong>协商缓存</strong></li> <li><code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li> <li><code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li> <li><code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li> <li><code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li></ul> <h2 id="防抖-节流"><a href="#防抖-节流" aria-hidden="true" class="header-anchor">#</a> 防抖/节流</h2> <p><strong>防抖</strong></p> <blockquote><p>在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用 underscore 的源码来解释防抖动</span>

<span class="token comment">/**
 * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */</span>
_<span class="token punctuation">.</span><span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> timeout<span class="token punctuation">,</span> args<span class="token punctuation">,</span> context<span class="token punctuation">,</span> timestamp<span class="token punctuation">,</span> result<span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 现在和上一次时间戳比较</span>
      <span class="token keyword">var</span> last <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timestamp<span class="token punctuation">;</span>
      <span class="token comment">// 如果当前间隔时间少于设定时间且大于0就重新设置定时器</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">&lt;</span> wait <span class="token operator">&amp;&amp;</span> last <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>later<span class="token punctuation">,</span> wait <span class="token operator">-</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 否则的话就是时间到了执行回调函数</span>
        timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          result <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
      <span class="token comment">// 获得时间戳</span>
      timestamp <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果定时器不存在且立即执行函数</span>
      <span class="token keyword">var</span> callNow <span class="token operator">=</span> immediate <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timeout<span class="token punctuation">;</span>
      <span class="token comment">// 如果定时器不存在就创建一个</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>later<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果需要立即执行函数的话 通过 apply 执行</span>
        result <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>整体函数实现
对于按钮防点击来说的实现</p></blockquote> <ul><li>开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了</li> <li>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数
<strong>节流</strong></li></ul> <blockquote><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 *
 * @param  {function}   func      回调函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。
 *                                如果想忽略结尾函数的调用，传入{trailing: false}
 *                                两者不能共存，否则函数不能执行
 * @return {function}             返回客户调用函数
 */</span>
_<span class="token punctuation">.</span><span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">,</span> result<span class="token punctuation">;</span>
    <span class="token keyword">var</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 之前的时间戳</span>
    <span class="token keyword">var</span> previous <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果 options 没传则设为空对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">)</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 定时器回调函数</span>
    <span class="token keyword">var</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果设置了 leading，就将 previous 设为 0</span>
      <span class="token comment">// 用于下面函数的第一个 if 判断</span>
      previous <span class="token operator">=</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span>
      timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      result <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获得当前时间戳</span>
      <span class="token keyword">var</span> now <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 首次进入前者肯定为 true</span>
	  <span class="token comment">// 如果需要第一次不执行函数</span>
	  <span class="token comment">// 就将上次时间戳设为当前的</span>
      <span class="token comment">// 这样在接下来计算 remaining 的值时会大于0</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>previous <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> previous <span class="token operator">=</span> now<span class="token punctuation">;</span>
      <span class="token comment">// 计算剩余时间</span>
      <span class="token keyword">var</span> remaining <span class="token operator">=</span> wait <span class="token operator">-</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous<span class="token punctuation">)</span><span class="token punctuation">;</span>
      context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
      <span class="token comment">// 如果当前调用已经大于上次调用时间 + wait</span>
      <span class="token comment">// 或者用户手动调了时间</span>
 	  <span class="token comment">// 如果设置了 trailing，只会进入这个条件</span>
	  <span class="token comment">// 如果没有设置 leading，那么第一次会进入这个条件</span>
	  <span class="token comment">// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span>
	  <span class="token comment">// 其实还是会进入的，因为定时器的延时</span>
	  <span class="token comment">// 并不是准确的时间，很可能你设置了2秒</span>
	  <span class="token comment">// 但是他需要2.2秒才触发，这时候就会进入这个条件</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> remaining <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果存在定时器就清理掉否则会调用二次回调</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
          timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        previous <span class="token operator">=</span> now<span class="token punctuation">;</span>
        result <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>trailing <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断是否设置了定时器和 trailing</span>
	    <span class="token comment">// 没有的话就开启一个定时器</span>
        <span class="token comment">// 并且不能不能同时设置 leading 和 trailing</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>later<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="谈谈变量提升？"><a href="#谈谈变量提升？" aria-hidden="true" class="header-anchor">#</a> 谈谈变量提升？</h2> <blockquote><p>当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境</p></blockquote> <ul><li>接下来让我们看一个老生常谈的例子，<code>var</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// call b</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'Hello world'</span>

<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call b'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">变量提升</p> <p>这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为<code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p></div> <p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// call b second</span>

<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call b fist'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call b second'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">'Hello world'</span>
</code></pre></div><blockquote><p>复制代码<code>var</code>会产生很多错误，所以在<code>ES6</code>中引入了<code>let</code>。<code>let</code>不能在声明前使用，但是这并不是常说的<code>let</code>不会提升，<code>let</code>提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p></blockquote> <h2 id="defer和async"><a href="#defer和async" aria-hidden="true" class="header-anchor">#</a> defer和async</h2> <ul><li><code>defer</code>并行加载<code>js</code>文件，会按照页面上<code>script</code>标签的顺序执行</li> <li><code>async</code>并行加载<code>js</code>文件，下载完成立即执行，不会按照页面上<code>script</code>标签的顺序执行</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front_end_studying/base/css.html" class="prev">
          CSS 部分
        </a></span> <span class="next"><a href="/front_end_studying/mvvm/">
          概念
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/front_end_studying/assets/js/app.9eec5fda.js" defer></script><script src="/front_end_studying/assets/js/6.14b46a33.js" defer></script>
  </body>
</html>
