<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 部分 | 前端面试宝典</title>
    <meta name="description" content="大厂前端面试题整理">
    <link rel="icon" href="/front_end_studying/avatar.jpg">
    
    <link rel="preload" href="/front_end_studying/assets/css/0.styles.0373d4c1.css" as="style"><link rel="preload" href="/front_end_studying/assets/js/app.9eec5fda.js" as="script"><link rel="preload" href="/front_end_studying/assets/js/19.0c4dabed.js" as="script"><link rel="prefetch" href="/front_end_studying/assets/js/10.4924765d.js"><link rel="prefetch" href="/front_end_studying/assets/js/11.993bcc99.js"><link rel="prefetch" href="/front_end_studying/assets/js/12.2aeaf266.js"><link rel="prefetch" href="/front_end_studying/assets/js/13.542f4e4d.js"><link rel="prefetch" href="/front_end_studying/assets/js/14.45795388.js"><link rel="prefetch" href="/front_end_studying/assets/js/15.96e5648e.js"><link rel="prefetch" href="/front_end_studying/assets/js/16.ff3a5cd8.js"><link rel="prefetch" href="/front_end_studying/assets/js/17.a0170075.js"><link rel="prefetch" href="/front_end_studying/assets/js/18.2a23d5f9.js"><link rel="prefetch" href="/front_end_studying/assets/js/2.d222fbca.js"><link rel="prefetch" href="/front_end_studying/assets/js/20.87104d4f.js"><link rel="prefetch" href="/front_end_studying/assets/js/21.f7903bda.js"><link rel="prefetch" href="/front_end_studying/assets/js/3.23267d51.js"><link rel="prefetch" href="/front_end_studying/assets/js/4.4eab954a.js"><link rel="prefetch" href="/front_end_studying/assets/js/5.1754e614.js"><link rel="prefetch" href="/front_end_studying/assets/js/6.14b46a33.js"><link rel="prefetch" href="/front_end_studying/assets/js/7.09f12188.js"><link rel="prefetch" href="/front_end_studying/assets/js/8.03407f1f.js"><link rel="prefetch" href="/front_end_studying/assets/js/9.d435ade3.js">
    <link rel="stylesheet" href="/front_end_studying/assets/css/0.styles.0373d4c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front_end_studying/" class="home-link router-link-active"><!----> <span class="site-name">前端面试宝典</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front_end_studying/base/html.html" class="nav-link">HTML</a></div><div class="nav-item"><a href="/front_end_studying/base/css.html" class="nav-link">CSS</a></div><div class="nav-item"><a href="/front_end_studying/base/javascript.html" class="nav-link">JavaScript</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">MVVM</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/vue.html" class="nav-link router-link-exact-active router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react.html" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/angular.html" class="nav-link">Angular</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/weex.html" class="nav-link">Weex</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react-native.html" class="nav-link">React Native</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/flutter.html" class="nav-link">Flutter</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/miniprogram.html" class="nav-link">小程序</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/network.html" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/data_structure.html" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/algorithm.html" class="nav-link">算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">常用代码</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/code/easy.html" class="nav-link">LeetCode - 简单</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/medium.html" class="nav-link">LeetCode - 中等</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/difficulty.html" class="nav-link">LeetCode - 困难</a></li></ul></div></div><div class="nav-item"><a href="https://llwanran.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/LLwanran" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front_end_studying/base/html.html" class="nav-link">HTML</a></div><div class="nav-item"><a href="/front_end_studying/base/css.html" class="nav-link">CSS</a></div><div class="nav-item"><a href="/front_end_studying/base/javascript.html" class="nav-link">JavaScript</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">MVVM</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/vue.html" class="nav-link router-link-exact-active router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react.html" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/angular.html" class="nav-link">Angular</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/weex.html" class="nav-link">Weex</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/react-native.html" class="nav-link">React Native</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/flutter.html" class="nav-link">Flutter</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/mvvm/miniprogram.html" class="nav-link">小程序</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/network.html" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/data_structure.html" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/computer/algorithm.html" class="nav-link">算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">常用代码</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front_end_studying/code/easy.html" class="nav-link">LeetCode - 简单</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/medium.html" class="nav-link">LeetCode - 中等</a></li><li class="dropdown-item"><!----> <a href="/front_end_studying/code/difficulty.html" class="nav-link">LeetCode - 困难</a></li></ul></div></div><div class="nav-item"><a href="https://llwanran.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/LLwanran" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>MVVM</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/front_end_studying/mvvm/" class="sidebar-link">概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/#对于-mvvm-的理解" class="sidebar-link">对于 MVVM 的理解</a></li></ul></li><li><a href="/front_end_studying/mvvm/vue.html" class="active sidebar-link">Vue 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-的优点是什么？" class="sidebar-link">vue 的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#请详细说下你对-vue-生命周期的理解" class="sidebar-link">请详细说下你对 vue 生命周期的理解</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#请列举出-3-个-vue-中常用的生命周期钩子函数？" class="sidebar-link">请列举出 3 个 Vue 中常用的生命周期钩子函数？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#nexttick" class="sidebar-link">NextTick</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-实现数据双向绑定的原理：object-defineproperty" class="sidebar-link">Vue 实现数据双向绑定的原理：Object.defineProperty()</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-组件间的参数传递" class="sidebar-link">Vue 组件间的参数传递</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#父组件与子组件传值" class="sidebar-link">父组件与子组件传值</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-的路由实现：hash-模式-和-history-模式" class="sidebar-link">Vue 的路由实现：hash 模式 和 history 模式</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-路由的钩子函数" class="sidebar-link">vue 路由的钩子函数</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vuex-是什么？怎么使用？哪种功能场景使用它？" class="sidebar-link">vuex 是什么？怎么使用？哪种功能场景使用它？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#v-if-和-v-show-区别" class="sidebar-link">v-if 和 v-show 区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#route和-router的区别" class="sidebar-link">$route和$router的区别</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#如何让-css-只在当前组件中起作用？" class="sidebar-link">如何让 CSS 只在当前组件中起作用？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#keep-alive-keep-alive-的作用是什么？" class="sidebar-link">&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-组件-data-为什么必须是函数" class="sidebar-link">Vue 组件 data 为什么必须是函数</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#在-vue-中使用插件的步骤" class="sidebar-link">在 Vue 中使用插件的步骤</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-cli-工程技术集合介绍" class="sidebar-link">vue-cli 工程技术集合介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#问题一：构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？" class="sidebar-link">问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#路由之间跳转？" class="sidebar-link">路由之间跳转？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#声明式（标签跳转）" class="sidebar-link">声明式（标签跳转）</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#编程式（-js-跳转）" class="sidebar-link">编程式（ js 跳转）</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#实现-vue-ssr" class="sidebar-link">实现 Vue SSR</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#其基本实现原理" class="sidebar-link">其基本实现原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-computed-实现" class="sidebar-link">Vue computed 实现</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#vue-complier-实现" class="sidebar-link">Vue complier 实现</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/vue.html#怎么快速定位哪个组件出现性能问题" class="sidebar-link">怎么快速定位哪个组件出现性能问题</a></li></ul></li><li><a href="/front_end_studying/mvvm/react.html" class="sidebar-link">React 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-生命周期函数" class="sidebar-link">react 生命周期函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#初始化阶段" class="sidebar-link">初始化阶段</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#运行中状态" class="sidebar-link">运行中状态</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#销毁阶段" class="sidebar-link">销毁阶段</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-性能优化是哪个周期函数" class="sidebar-link">react 性能优化是哪个周期函数</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-性能优化方案" class="sidebar-link">react 性能优化方案</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-中-keys-的作用是什么？" class="sidebar-link">React 中 keys 的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#传入-setstate-函数的第二个参数的作用是什么？" class="sidebar-link">传入 setState 函数的第二个参数的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-中-refs-的作用是什么" class="sidebar-link">React 中 refs 的作用是什么</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#在生命周期中的哪一步你应该发起-ajax-请求" class="sidebar-link">在生命周期中的哪一步你应该发起 AJAX 请求</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#shouldcomponentupdate-的作用" class="sidebar-link">shouldComponentUpdate 的作用</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#如何告诉-react-它应该编译生产环境版" class="sidebar-link">如何告诉 React 它应该编译生产环境版</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#概述下-react-中的事件处理逻辑" class="sidebar-link">概述下 React 中的事件处理逻辑</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#createelement-与-cloneelement-的区别是什么" class="sidebar-link">createElement 与 cloneElement 的区别是什么</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#redux-中间件" class="sidebar-link">redux 中间件</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#redux-有什么缺点" class="sidebar-link">redux 有什么缺点</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-组件的划分业务组件技术组件？" class="sidebar-link">react 组件的划分业务组件技术组件？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#为什么虚拟-dom-会提高性能" class="sidebar-link">为什么虚拟 dom 会提高性能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#具体实现步骤如下" class="sidebar-link">具体实现步骤如下</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#diff-算法？" class="sidebar-link">diff 算法？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-的虚拟-dom-是怎么实现的" class="sidebar-link">react 的虚拟 dom 是怎么实现的</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#react-的渲染过程中，兄弟节点之间是怎么处理的？也就是-key-值不一样的时候" class="sidebar-link">react 的渲染过程中，兄弟节点之间是怎么处理的？也就是 key 值不一样的时候</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#简述-flux-思想" class="sidebar-link">简述 flux 思想</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#说说你用-react-有什么坑点？" class="sidebar-link">说说你用 react 有什么坑点？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#_1-jsx-做表达式判断时候，需要强转为-boolean-类型" class="sidebar-link">1. JSX 做表达式判断时候，需要强转为 boolean 类型</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#_2-尽量不要在-componentwillreviceprops-里使用-setstate，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃" class="sidebar-link">2. 尽量不要在 componentWillReviceProps 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#_3-给组件添加-ref-时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的-prop-处理，让-ref-属性接受到新函数的时候，react-内部会先清空-ref，也就是会以-null-为回调参数先执行一次-ref-这个-props，然后在以该组件的实例执行一次-ref，所以用匿名函数做-ref-的时候，有的时候去-ref-赋值后的属性会取到-null" class="sidebar-link">3. 给组件添加 ref 时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的 prop 处理，让 ref 属性接受到新函数的时候，react 内部会先清空 ref，也就是会以 null 为回调参数先执行一次 ref 这个 props，然后在以该组件的实例执行一次 ref，所以用匿名函数做 ref 的时候，有的时候去 ref 赋值后的属性会取到 null</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#_4-遍历子节点的时候，不要用-index-作为组件的-key-进行传入" class="sidebar-link">4. 遍历子节点的时候，不要用 index 作为组件的 key 进行传入</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#我现在有一个-button，要用-react-在上面绑定点击事件，要怎么做？" class="sidebar-link">我现在有一个 button，要用 react 在上面绑定点击事件，要怎么做？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#你觉得你这样设置点击事件会有什么问题吗？" class="sidebar-link">你觉得你这样设置点击事件会有什么问题吗？</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react.html#那给我介绍一下-react" class="sidebar-link">那给我介绍一下 react</a></li></ul></li><li><a href="/front_end_studying/mvvm/angular.html" class="sidebar-link">Angular 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/angular.html#使用-angular-2，和使用-angular-1-相比，有什么优势？" class="sidebar-link">使用 Angular 2，和使用 Angular 1 相比，有什么优势？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/angular.html#ng-show-ng-hide与ng-if的区别？" class="sidebar-link">ng-show/ng-hide与ng-if的区别？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/angular.html#解释下什么是-rootscrope以及和-scope的区别？" class="sidebar-link">解释下什么是$rootScrope以及和$scope的区别？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/angular.html#表达式-yourmodel-是如何工作的？" class="sidebar-link">表达式{yourModel}是如何工作的？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/angular.html#angular-中的-digest-周期是什么？" class="sidebar-link">Angular 中的 digest 周期是什么？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/angular.html#列出至少三种实现不同模块之间通信方式？" class="sidebar-link">列出至少三种实现不同模块之间通信方式？</a></li></ul></li><li><a href="/front_end_studying/mvvm/weex.html" class="sidebar-link">Weex 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/weex.html#“html-标签”" class="sidebar-link">“html 标签”</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/weex.html#weex-环境中没有-dom" class="sidebar-link">Weex 环境中没有 DOM</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/weex.html#支持有限的事件" class="sidebar-link">支持有限的事件</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/weex.html#没有-bom-但可以调用原生-api" class="sidebar-link">没有 BOM 但可以调用原生 API</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/weex.html#样式差异" class="sidebar-link">样式差异</a></li></ul></li><li><a href="/front_end_studying/mvvm/react-native.html" class="sidebar-link">React Native 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react-native.html#创建新项目" class="sidebar-link">创建新项目</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react-native.html#启动项目" class="sidebar-link">启动项目</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/react-native.html#目录结构说明" class="sidebar-link">目录结构说明</a></li></ul></li><li><a href="/front_end_studying/mvvm/flutter.html" class="sidebar-link">Flutter 部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/flutter.html#flutter-是什么？" class="sidebar-link">Flutter 是什么？</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/flutter.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/flutter.html#在-macos-上搭建-flutter-开发环境" class="sidebar-link">在 macOS 上搭建 Flutter 开发环境</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/flutter.html#介绍" class="sidebar-link">介绍</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/flutter.html#dart" class="sidebar-link">Dart</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/flutter.html#语法" class="sidebar-link">语法</a></li></ul></li></ul></li><li><a href="/front_end_studying/mvvm/miniprogram.html" class="sidebar-link">小程序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#登录" class="sidebar-link">登录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#openid" class="sidebar-link">OpenID</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#unionid" class="sidebar-link">UnionID</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#视图层-view" class="sidebar-link">视图层 View</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#wxml-weixin-markup-language-用于描述页面的结构。" class="sidebar-link">WXML(WeiXin Markup language) 用于描述页面的结构。</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#wxs-weixin-script-是小程序的一套脚本语言，结合-wxml，可以构建出页面的结构。" class="sidebar-link">WXS (WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#wxss-weixin-style-sheet-用于描述页面的样式。" class="sidebar-link">WXSS(WeiXin Style Sheet) 用于描述页面的样式。</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#组件-component-是视图的基本组成单元。" class="sidebar-link">组件(Component)是视图的基本组成单元。</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#知识点" class="sidebar-link">知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#app" class="sidebar-link">app()</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#page" class="sidebar-link">page</a></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#事件" class="sidebar-link">事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/front_end_studying/mvvm/miniprogram.html#mpvue" class="sidebar-link">mpvue</a></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>常用代码</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-部分"><a href="#vue-部分" aria-hidden="true" class="header-anchor">#</a> Vue 部分</h1> <h2 id="vue-的优点是什么？"><a href="#vue-的优点是什么？" aria-hidden="true" class="header-anchor">#</a> vue 的优点是什么？</h2> <ul><li>低耦合。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>ViewModel</code>可以绑定到不同的<code>&quot;View&quot;</code>上，当 View 变化的时候 Model 可以不变，当<code>Model</code>变化的时候<code>View</code>也可以不变</li> <li>可重用性。你可以把一些视图逻辑放在一个<code>ViewModel</code>里面，让很多<code>view</code>重用这段视图逻辑</li> <li>可测试。界面素来是比较难于测试的，而现在测试可以针对<code>ViewModel</code>来写</li></ul> <h2 id="请详细说下你对-vue-生命周期的理解"><a href="#请详细说下你对-vue-生命周期的理解" aria-hidden="true" class="header-anchor">#</a> 请详细说下你对 vue 生命周期的理解</h2> <blockquote><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote> <ul><li>创建前/后： 在<code>beforeCreate</code>阶段，<code>vue</code>实例的挂载元素<code>el</code>和数据对象<code>data</code>都为<code>undefined</code>，还未初始化。在<code>created</code>阶段，<code>vue</code>实例的数据对象<code>data</code>有了，el 还没有</li> <li>载入前/后：在<code>beforeMount</code>阶段，<code>vue</code>实例的<code>$el</code>和<code>data</code>都初始化了，但还是挂载之前为虚拟的<code>dom</code>节点，<code>data.message</code>还未替换。在<code>mounted</code>阶段，<code>vue</code>实例挂载完成，<code>data.message</code>成功渲染。</li> <li>更新前/后：当<code>data</code>变化时，会触发<code>beforeUpdate</code>和<code>updated</code>方法</li> <li>销毁前/后：在执行<code>destroy</code>方法后，对<code>data</code>的改变不会再触发周期函数，说明此时<code>vue</code>实例已经解除了事件监听以及和<code>dom</code>的绑定，但是<code>dom</code>结构依然存在
<strong>什么是 vue 生命周期？</strong></li> <li>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、销毁等一系列过程，称之为 Vue 的生命周期。
<strong>vue 生命周期的作用是什么？</strong></li> <li>答：它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。
<strong>vue 生命周期总共有几个阶段？</strong></li> <li>答：它可以总共分为<code>8</code>个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。
<strong>第一次页面加载会触发哪几个钩子？</strong></li> <li>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>。
<strong>DOM 渲染在哪个周期中就已经完成？</strong></li> <li>答：<code>DOM</code>渲染在<code>mounted</code>中就已经完成了</li></ul> <h2 id="请列举出-3-个-vue-中常用的生命周期钩子函数？"><a href="#请列举出-3-个-vue-中常用的生命周期钩子函数？" aria-hidden="true" class="header-anchor">#</a> 请列举出 3 个 Vue 中常用的生命周期钩子函数？</h2> <ul><li><code>created</code>: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算,<code>watch/event</code>事件回调. 然而, 挂载阶段还没有开始,<code>$el</code>属性目前还不可见</li> <li><code>mounted</code>:<code>el</code>被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子。如果<code>root</code>实例挂载了一个文档内元素，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。</li> <li><code>activated</code>:<code>keep-alive</code>组件激活时调用</li></ul> <h2 id="nexttick"><a href="#nexttick" aria-hidden="true" class="header-anchor">#</a> NextTick</h2> <blockquote><p><code>nextTick</code>可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的<code>DOM</code></p></blockquote> <h2 id="vue-实现数据双向绑定的原理：object-defineproperty"><a href="#vue-实现数据双向绑定的原理：object-defineproperty" aria-hidden="true" class="header-anchor">#</a> Vue 实现数据双向绑定的原理：Object.defineProperty()</h2> <ul><li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通<code>Javascript</code>对象传给 Vue 实例来作为它的<code>data</code>选项时，Vue 将遍历它的属性，用<code>Object.defineProperty()</code>将它们转为<code>getter/setter</code>。用户看不到<code>getter/setter</code>，但是在内部它们让<code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li> <li>vue 的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析<code>{{}}</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（<code>input</code>）—&gt;数据<code>model</code>变更双向绑定效果。</li></ul> <h2 id="vue-组件间的参数传递"><a href="#vue-组件间的参数传递" aria-hidden="true" class="header-anchor">#</a> Vue 组件间的参数传递</h2> <h3 id="父组件与子组件传值"><a href="#父组件与子组件传值" aria-hidden="true" class="header-anchor">#</a> 父组件与子组件传值</h3> <blockquote><p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p></blockquote> <ul><li>子组件传给父组件：<code>$emit</code>方法传递参数
<strong>非父子组件间的数据传递，兄弟组件传值</strong> <blockquote><p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用<code>VUEX</code>，具体来说看需求）</p></blockquote></li></ul> <h2 id="vue-的路由实现：hash-模式-和-history-模式"><a href="#vue-的路由实现：hash-模式-和-history-模式" aria-hidden="true" class="header-anchor">#</a> Vue 的路由实现：hash 模式 和 history 模式</h2> <ul><li><code>hash</code>模式：在浏览器中符号<code>“#”</code>，#以及#后面的字符称之为<code>hash</code>，用<code>window.location.hash</code>读取。特点：<code>hash</code>虽然在<code>URL</code>中，但不被包括在<code>HTTP</code>请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。</li> <li><code>history</code>模式：h<code>istory</code>采用<code>HTML5</code>的新特性；且提供了两个新方法：<code>pushState()</code>，<code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更</li></ul> <h2 id="vue-路由的钩子函数"><a href="#vue-路由的钩子函数" aria-hidden="true" class="header-anchor">#</a> vue 路由的钩子函数</h2> <blockquote><p>首页可以控制导航跳转，<code>beforeEach</code>，<code>afterEach</code>等，一般用于页面<code>title</code>的修改。一些需要登录才能调整页面的重定向功能。</p></blockquote> <ul><li><code>beforeEach</code>主要有 3 个参数<code>to</code>，<code>from</code>，<code>next</code>。</li> <li><code>to</code>：<code>route</code>即将进入的目标路由对象。</li> <li><code>from</code>：<code>route</code>当前导航正要离开的路由。</li> <li><code>next</code>：<code>function</code>一定要调用该方法<code>resolve</code>这个钩子。执行效果依赖<code>next</code>方法的调用参数。可以控制网页的跳转</li></ul> <h2 id="vuex-是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex-是什么？怎么使用？哪种功能场景使用它？" aria-hidden="true" class="header-anchor">#</a> vuex 是什么？怎么使用？哪种功能场景使用它？</h2> <ul><li>只用来读取的状态集中放在<code>store</code>中； 改变状态的方式是提交<code>mutations</code>，这是个同步的事物； 异步逻辑应该封装在<code>action</code>中。</li> <li>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>… export</code></li> <li><strong>场景有</strong>：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li> <li><code>state</code>：<code>Vuex</code>使用单一状态树,即每个应用将仅仅包含一个<code>store</code>实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li> <li><code>mutations</code>：<code>mutations</code>定义的方法动态修改<code>Vuex</code>的<code>store</code>中的状态或数据</li> <li><code>getters</code>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</li> <li><code>action</code>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code>层通过<code>store.dispath</code>来分发<code>action</code> <code>modules</code>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理</li></ul> <h2 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" aria-hidden="true" class="header-anchor">#</a> v-if 和 v-show 区别</h2> <ul><li>答：<code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code></li></ul> <h2 id="route和-router的区别"><a href="#route和-router的区别" aria-hidden="true" class="header-anchor">#</a> <code>$route</code>和<code>$router</code>的区别</h2> <ul><li><code>$route</code>是“路由信息对象”，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li> <li>而<code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等</li></ul> <h2 id="如何让-css-只在当前组件中起作用？"><a href="#如何让-css-只在当前组件中起作用？" aria-hidden="true" class="header-anchor">#</a> 如何让 CSS 只在当前组件中起作用？</h2> <blockquote><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p></blockquote> <h2 id="keep-alive-keep-alive-的作用是什么？"><a href="#keep-alive-keep-alive-的作用是什么？" aria-hidden="true" class="header-anchor">#</a> <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的作用是什么？</h2> <ul><li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染
<blockquote><p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p></blockquote></li></ul> <h2 id="vue-组件-data-为什么必须是函数"><a href="#vue-组件-data-为什么必须是函数" aria-hidden="true" class="header-anchor">#</a> Vue 组件 data 为什么必须是函数</h2> <ul><li>每个组件都是<code>Vue</code>的实例。</li> <li>组件共享<code>data</code>属性，当<code>data</code>的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul> <h2 id="在-vue-中使用插件的步骤"><a href="#在-vue-中使用插件的步骤" aria-hidden="true" class="header-anchor">#</a> 在 Vue 中使用插件的步骤</h2> <ul><li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li> <li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, { someOption: true })</code></li></ul> <h2 id="vue-cli-工程技术集合介绍"><a href="#vue-cli-工程技术集合介绍" aria-hidden="true" class="header-anchor">#</a> vue-cli 工程技术集合介绍</h2> <h3 id="问题一：构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？"><a href="#问题一：构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？" aria-hidden="true" class="header-anchor">#</a> 问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</h3> <ul><li><code>vue.js</code>：<code>vue-cli</code>工程的核心，主要特点是 双向数据绑定 和 组件系统。</li> <li><code>vue-router</code>：<code>vue</code>官方推荐使用的路由框架。</li> <li><code>vuex</code>：专为<code>Vue.js</code>应用项目开发的状态管理器，主要用于维护<code>vue</code>组件间共用的一些 变量 和 方法。</li> <li><code>axios</code>（ 或者<code>fetch</code>、<code>ajax</code>）：用于发起<code>GET</code>、或<code>POST</code>等<code>http</code>请求，基于<code>Promise</code>设计。</li> <li><code>vuex</code>等：一个专为<code>vue</code>设计的移动端 UI 组件库。</li> <li>创建一个<code>emit.js</code>文件，用于<code>vue</code>事件机制的管理。</li> <li><code>webpack</code>：模块加载和<code>vue-cli</code>工程打包器。
<strong>问题二：vue-cli 工程常用的 npm 命令有哪些？</strong></li> <li>下载<code>node_modules</code>资源包的命令：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span>
</code></pre></div><ul><li>启动<code>vue-cli</code>开发环境的 npm 命令：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> run dev
</code></pre></div><ul><li><code>vue-cli</code>生成 生产环境部署资源 的<code>npm</code>命令：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> run build
</code></pre></div><ul><li>用于查看<code>vue-cli</code>生产环境部署资源文件大小的<code>npm</code>命令：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> run build --report
</code></pre></div><blockquote><p>在浏览器上自动弹出一个 展示<code>vue-cli</code>工程打包后<code>app.js</code>、<code>manifest.js</code>、<code>vendor.js</code>文件里面所包含代码的页面。可以具此优化<code>vue-cli</code>生产环境部署的静态资源，提升 页面 的加载速度</p></blockquote> <h2 id="路由之间跳转？"><a href="#路由之间跳转？" aria-hidden="true" class="header-anchor">#</a> 路由之间跳转？</h2> <h3 id="声明式（标签跳转）"><a href="#声明式（标签跳转）" aria-hidden="true" class="header-anchor">#</a> 声明式（标签跳转）</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>index<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="编程式（-js-跳转）"><a href="#编程式（-js-跳转）" aria-hidden="true" class="header-anchor">#</a> 编程式（ js 跳转）</h3> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="实现-vue-ssr"><a href="#实现-vue-ssr" aria-hidden="true" class="header-anchor">#</a> 实现 Vue SSR</h2> <h3 id="其基本实现原理"><a href="#其基本实现原理" aria-hidden="true" class="header-anchor">#</a> 其基本实现原理</h3> <ul><li><code>app.js</code>作为客户端与服务端的公用入口，导出<code>Vue</code>根实例，供客户端<code>entry</code>与服务端<code>entry</code>使用。客户端<code>entry</code>主要作用挂载到<code>DOM</code>上，服务端<code>entry</code>除了创建和返回实例，还进行路由匹配与数据预获取。</li> <li><code>webpack</code>为客服端打包一个<code>Client Bundle</code>，为服务端打包一个<code>Server Bundle</code>。</li> <li>服务器接收请求时，会根据<code>url</code>，加载相应组件，获取和解析异步数据，创建一个读取<code>Server Bundle</code>的<code>BundleRenderer</code>，然后生成<code>html</code>发送给客户端。</li> <li>客户端混合，客户端收到从服务端传来的<code>DOM</code>与自己的生成的 DOM 进行对比，把不相同的<code>DOM</code>激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到<code>stroe</code>里，这样，在客户端挂载到<code>DOM</code>之前，可以直接从<code>store</code>里取数据。首屏的动态数据通过<code>window.__INITIAL_STATE__</code>发送到客户端
<blockquote><p><code>Vue SSR</code>的实现，主要就是把<code>Vue</code>的组件输出成一个完整<code>HTML</code>,<code>vue-server-renderer</code>就是干这事的</p></blockquote></li> <li><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至<code>HTML</code>、客户端混合（<code>hydration</code>）、缓存等等。 相比于其他模板引擎（<code>ejs</code>,<code>jade</code>等），最终要实现的目的是一样的，性能上可能要差点</li></ul> <h2 id="vue-computed-实现"><a href="#vue-computed-实现" aria-hidden="true" class="header-anchor">#</a> Vue computed 实现</h2> <ul><li>建立与其他属性（如：<code>data</code>、<code>Store</code>）的联系；</li> <li>属性改变后，通知计算属性重新计算
<blockquote><p>实现时，主要如下</p></blockquote></li> <li>初始化<code>data</code>， 使用<code>Object.defineProperty</code>把这些属性全部转为<code>getter/setter</code>。</li> <li>初始化<code>computed</code>, 遍历<code>computed</code>里的每个属性，每个<code>computed</code>属性都是一个<code>watch</code>实例。每个属性提供的函数作为属性的<code>getter</code>，使用<code>Object.defineProperty</code>转化。</li> <li><code>Object.defineProperty getter</code>依赖收集。用于依赖发生变化时，触发属性重新计算。</li> <li>若出现当前<code>computed</code>计算属性嵌套其他<code>computed</code>计算属性时，先进行其他的依赖收集</li></ul> <h2 id="vue-complier-实现"><a href="#vue-complier-实现" aria-hidden="true" class="header-anchor">#</a> Vue complier 实现</h2> <ul><li>模板解析这种事，本质是将数据转化为一段<code>html</code>，最开始出现在后端，经过各种处理吐给前端。随着各种<code>mv*</code>的兴起，模板解析交由前端处理。</li> <li>总的来说，<code>Vue complier</code>是将<code>template</code>转化成一个<code>render</code>字符串。
<blockquote><p>可以简单理解成以下步骤：</p></blockquote></li> <li><code>parse</code>过程，将<code>template</code>利用正则转化成<code>AST</code>抽象语法树。</li> <li><code>optimize</code>过程，标记静态节点，后<code>diff</code>过程跳过静态节点，提升性能。</li> <li><code>generate</code>过程，生成<code>render</code>字符串</li></ul> <h2 id="怎么快速定位哪个组件出现性能问题"><a href="#怎么快速定位哪个组件出现性能问题" aria-hidden="true" class="header-anchor">#</a> 怎么快速定位哪个组件出现性能问题</h2> <blockquote><p>用<code>timeline</code>工具。 大意是通过<code>timeline</code>来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front_end_studying/mvvm/" class="prev router-link-active">
          概念
        </a></span> <span class="next"><a href="/front_end_studying/mvvm/react.html">
          React 部分
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/front_end_studying/assets/js/app.9eec5fda.js" defer></script><script src="/front_end_studying/assets/js/19.0c4dabed.js" defer></script>
  </body>
</html>
